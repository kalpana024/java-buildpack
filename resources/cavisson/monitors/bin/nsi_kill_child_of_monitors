#########################################################################################################################
#
#Purpose: This is a temprary tool which will kill child of custom monitors\
#
#Working: This shell monitors running status parent of custom monitor on a fixed interval of time and if parent of custom #monitor is not running then it will kill all its childs.
#
#Use:nsi_kill_child_of_monitors -p <process id of custom monitor> -i <time interval> -f <temprary file generated by custom monitor> -D <debug>
#
#Issue: This will fail if the time interval is more than 10 because this shell itself killed before killing child of custom monitor   
#
#By: Manish kumar Mishra
#Date: 27 August 2011 06:03 PM
#
#########################################################################################################################


PARENT_ID=""
CHILD_ID=""
freq=10
PARENT_STATUS=""
OUTPUT_FILE=""
NUM_OF_CHILD=0
DEBUG=0 #default off 
DEBUG_LOG_FILE=$CAV_MON_HOME/logs/nsi_kill_child_of_monitors.log.$$
TEMP_PROCESS_FILE=$CAV_MON_HOME/logs/nsi_kill_child_of_monitors.$$

#Set CAV_MON_HOME to allow testing from commnad line
if [ "X$CAV_MON_HOME" = "X" ]; then
  if [ -d /opt/cavisson/monitors ];then
    export CAV_MON_HOME="/opt/cavisson/monitors"
  elif [ -d ~/cavisson/monitors ];then
    export CAV_MON_HOME=~/cavisson/monitors
  else
    echo "CAV_MON_HOME is not set"
    exit -1
  fi
fi

#Source in all cases
if [ -f $CAV_MON_HOME/sys/cmon.env ];then
. $CAV_MON_HOME/sys/cmon.env
fi

. $CAV_MON_HOME/bin/ns_check_monitor_func.sh

debug_log()
{
  if [ "X$DEBUG" = "X1" ]; then
    echo "`date +\ '%F %X'` | $*" >> $DEBUG_LOG_FILE
  fi
}

set_ps_cmd()
{
  debug_log "Method called: set_ps_cmd"
  OS_NAME=`uname`
  debug_log "OS_NAME=$OS_NAME"
  if [ "X$OS_NAME" = "XSunOS" ]; then
    #PS_CMD_FOR_DATA="/usr/bin/ps"
    PS_CMD_FOR_DATA="/usr/bin/pgrep"
  else #Linux,AIX
    PS_CMD_FOR_DATA="ps"
  fi
  debug_log "PS_CMD_FOR_DATA=$PS_CMD_FOR_DATA"
  debug_log "Method End."
}

get_orig_args()
{
  i=0
  for pid in `echo $CHILD_ID`
  do
    ps_orig_args[$i]=`ps -p $pid -o "args" | tail -1` 
    debug_log "Orig Args of pid=$pid at index $i = ${ps_orig_args[$i]}"

    i=`expr $i + 1`
  done
}

get_cur_args()
{
  i=0
  for pid in `echo $CHILD_ID`
  do
    ps_cur_args[$i]=`ps -p $pid -o "args" | tail -1` 
    debug_log "Cur Args of pid=$pid at index $i = ${ps_cur_args[$i]}"

    i=`expr $i + 1`
  done
}


get_child_id()
{
  debug_log "Method called: get_child_id"
  debug_log "OS_NAME=$OS_NAME"

  myPid=$$

  if [ "X$OS_NAME" = "XAIX" ]; then
    PS_CMD_FOR_GETTING_CHILD="$PS_CMD_FOR_DATA -L $PARENT_ID"
  elif [ "X$OS_NAME" = "XSunOS" ]; then
    PS_CMD_FOR_GETTING_CHILD="$PS_CMD_FOR_DATA -P $PARENT_ID"
  else
    PS_CMD_FOR_GETTING_CHILD="$PS_CMD_FOR_DATA --ppid $PARENT_ID"
  fi

  debug_log "PS_CMD_FOR_GETTING_CHILD=$PS_CMD_FOR_GETTING_CHILD"

  # Give time for parent to create it's child processes
  lib_sleep 5

  $PS_CMD_FOR_GETTING_CHILD >$TEMP_PROCESS_FILE 2>> /dev/null  
  NUM_OF_CHILD=`cat $TEMP_PROCESS_FILE | grep -vw $myPid | awk '{print $1}' | wc -l`
  NUM_LINE=`expr $NUM_OF_CHILD - 1`
  debug_log "NUM_OF_CHILD=$NUM_OF_CHILD,NUM_LINE=$NUM_LINE"
  
  #Manish: Since in solaris ouput of $PS_CMD_FOR_DATA -L $PARENT_ID is not contain header no need to tail 
  if [ "X$OS_NAME" = "XSunOS" ]; then
    CHILD_ID=`cat $TEMP_PROCESS_FILE | grep -vw $myPid | awk '{printf $1" "}'`
  else
    CHILD_ID=`cat $TEMP_PROCESS_FILE | grep -vw $myPid | tail -$NUM_LINE | awk '{printf $1" "}'`
  fi

  debug_log "NUM_OF_CHILD=$NUM_OF_CHILD,NUM_LINE=$NUM_LINE,CHILD_ID=$CHILD_ID"
  lib_trace_log "nsi_kill_child_of_monitors" "Childs of monitor process (pid, ppid, args: `ps -p $PARENT_ID -o "pid ppid args" | tail -1`) : $CHILD_ID"

  get_orig_args

  rm -f $TEMP_PROCESS_FILE 
  debug_log "Method End."
}

check_and_kill_child()
{

  get_cur_args
  idx=0
  for pid in `echo $CHILD_ID`
  do
    if [ "X${ps_cur_args[$idx]}" = "X${ps_orig_args[$idx]}" ]; then
      #lib_kill_process_using_pid "nsi_kill_child_of_monitors" "$CHILD_ID"        
      lib_kill_process_using_pid "nsi_kill_child_of_monitors" "$pid"        
    else
      lib_trace_log "nsi_kill_child_of_monitors" "Child process args are not same. So not killing it. PID=$pid. Cur Args = ${ps_cur_args[$idx]} and Orig Args = ${ps_orig_args[$idx]}"

    fi
    idx=`expr $idx + 1`
  done

  debug_log "OUTPUT_FILE=$OUTPUT_FILE, CHILD_ID=$CHILD_ID"
  rm -f $OUTPUT_FILE
  exit 0
}

kill_child()
{
  debug_log "Method called: kill_child"

  ps -p $PARENT_ID >>/dev/null
  if [ $? != 0 ]; then
    echo "Error: parent process (pid = $PARENT_ID) is not running"
    lib_trace_log "nsi_kill_child_of_monitors" "Error: parent process (pid = $PARENT_ID) is not running"
    exit -1
  fi

  get_child_id
  debug_log "PARENT_ID=$PARENT_ID,CHILD_ID=$CHILD_ID"

  #If may be possible this kill monitor tool die before parent die
  #So tracking signal by trap command and if this tool die then kill parent as well as child
  # Signal               -                Meaning
  #   1                  -    Hangup detected on controlling terminal or death of controlling process
  #   2                  -    Interrupt from keyboard
  #   3                  -    Quit from keyboard
  #   4                  -    Illegal Instruction
  #   5                  -    SIGTRAP
  #   15                 -    Termination signal           
  trap "kill -9 $CHILD_ID; rm -f $OUTPUT_FILE; exit 1" 1 2 3 4 5 15

  while true
  do
    debug_log "freq=$freq, CHILD_ID=$CHILD_ID"
    if [ "X$CHILD_ID" = "X0" -o "X$CHILD_ID" = "X" ];then
      lib_trace_log "nsi_kill_child_of_monitors" "No child of monitor process (pid=$PARENT_ID, args=`ps -p $PARENT_ID -o "args" | tail -1`) is running."
      exit -1
    else
      lib_sleep $freq
      ps -p $PARENT_ID >>/dev/null
      RET=$?
      debug_log "RET=$RET"
      if [ "X$RET" != "X0" ]; then
        check_and_kill_child
      fi
    fi
  done
  debug_log "Method End."
}


Usage()
{
  echo "Error: Incorrect Usage!"
  echo "Usage:"
  echo "-p is mandatry and other are optional"
  echo "-p: this option is for parent id, mandatry "
  echo "-i: used for interval (in seconds),( default -i 10)"
  echo "-f: temprary file generated by custom monitor"
  echo "-D: to on debug log"
  exit -1
}

set_ps_cmd
while getopts p:i:f:D? arg
do 
  case $arg in 
    p)PARENT_ID=$OPTARG ;;  #Parent process ID whose child need to be killed
    i)freq=$OPTARG
      echo $freq | grep '^[0-9]*$' 2>&1 >/dev/null
      if [ $? != 0 ];then
        echo "Integer expression must required with -i option!"
        exit -1
      fi
      ;;
    f)OUTPUT_FILE=$OPTARG
      ;;
    D)DEBUG="1"
      ;;
    *) Usage ;;
    ?) Usage ;;
  esac
done

if [ $# -eq 0 ];then
  Usage
  exit -1
fi

if [ "X$PARENT_ID" = "X" ];then
  exit -1
fi 

kill_child

exit 0
